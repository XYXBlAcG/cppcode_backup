# 题目 For mad der (Formatter)

> 题目很简单，学了1.1就会做. ——问号

## 题目背景

故事发生在 土也王求 的 公元907年.

为了无时无刻让人们听到der的语文课，使得不要让唐完了，「问号」用「乐乐」（读作月月）博士开发的C--语言创造了一个虚拟的der，有一天der突然被bug（真）袭击了，开始疯狂输出，「问号」立刻向一位叫「程宇翔」的巨佬求救，「程宇翔」在电脑上写好代码后就大脑过载消失了，但是当时存储空间是寸土寸金的，大约 $2147483648$ 张纸才能写一篇代码，因此他的代码没有经过格式化，「问号」并不能看懂. （悲）

而且唐朝是没有VSCode这种可以一键格式化代码的软件的，当时的人都是一个字一个字格式化的. （当时的人只会用不能安装插件的Vim）（大悲）

问号希望你可以在 $1000ms$ 内将他的代码格式化，并且输出一些关键性的代码使得「问号」进行调试，否则安禄山就要进长安了.（无慈悲）

## 题目内容

输入一段C++代码，然后格式化代码，代码长度为 $n\;(n\le10^6)$

要求字符串中的内容不被格式化，注释里的代码需要被格式化，

A.在所有下面给出的符号的前后添加空格，符号包括`+-*/=><|^~`, 为了难度保证不用考虑`%`和`&`

B.同时包括`&&`和`||`和`<<`和`>>`和`?`和`:`，如果空格已经添加过则不添加，对于逗号，清除它前面的空格，在后面加一个空格，如果空格已经添加过则不添加.

如果本行的第一个字符（忽略空格）为`#`并且后面有单词`include`或者`define`则对于`<`和`>`不执行添加空格的操作，

保证`#`号后面不会出现这两个单词之外的单词

每个分号后面添加换行，如果已经换行则不添加，

C.对于没有添加缩进的地方，自动添加大小为 $4$ 个空格的缩进，

左大括号需要换一行，右大括号也需要单独换一行，缩进与左大括号的那一行相同.

对于读进来的每一行（而不是代码的每一行）清除最前面和最后面的空格.

保证在代码结束的后一行为`end`.

保证不会出现分号连续压行，只因「程宇翔」觉得这个很不好看，如下解释：

```cpp
int a, b, c; // 合法
int a; int b; int c; // 不合法
int a;
int b;
int c; // line 3 - 5 合法
```





之后给出 $m\;(m\le 1000)$ 次询问，每次给出 $i,j$ ，回答第 $i$ 个代码块的第 $j$ 个语句是什么，请输出格式化后的语句.

保证一定存在答案，保证不会询问不含语句的代码块.

为了更直观地理解询问这个过程，我将用一段代码做演示：

```cpp
#include <cstdio> // 代码块 1

// 实际给出的测试例中不可能出现上面的空行
typedef long long lld; // 代码块 2
const int LN = 17, N = (1 << LN) + 11; // 代码块 3
int n, m; // 代码块 4
lld sum[N], tag[N]; // 代码块 5
// pushup // 不算
void up(int v){ // 代码块 6
	sum[v] = sum[v << 1] + sum[v << 1 | 1]; // 代码块 6 语句 1
} // 忽略
/*modify*/ // 不算
void modify(int q, lld& val){ // 代码块 7
	sum[q] += val << (__builtin_clz(q) - (32 - LN)); // 代码块 7 语句 1
	tag[q] += val; // 代码块 7 语句 2
}
void solve(){ // 代码块 8
	while(m--){ // 代码块 9
		int op, l, r, i; // 代码块 9 语句 1
		lld val; // 代码块 9 语句 2
		scanf("%d%d%d", &op, &l, &r); // 代码块 9 语句 3
		r++; // 代码块 9 语句 4
		if(op == 1){ // 代码块 10
			scanf("%lld", &val); // 代码块 10 语句 1
			upd = modify; // 代码块 10 语句 2
		}else{ // 代码块 11
			val = 0; // 代码块 11 语句 1
			upd = query; // 代码块 11 语句 2
    }
}

```

像代码块1，代码块2，代码块3这样的可能会被问到，像代码块6，代码块7这样的永远不会被问到.

<b>请仔细阅读前面的需求和样例。为了降低题目难度，题目中对格式化代码的规则发生了一些改变。</b>

<b>同时因为为了防止你使用`system()`函数，题目改变了一些规则.</b>

<b>请不要尝试用任何除手写之外的任何奇淫异巧完成此题目，网上可以搜索到的开源C++格式化代码程序如果要完成所有功能而非以上列出的功能，需要8421行. </b> <del>但是其实有几百行的注释，另外它也可以格式化C#和Java</del> <del>但是他总共写了670 KB，而且注释明显更少</del>

保证输入的代码完全可以编译运行，命令为 `g++ -Wall -Wextra -g3 *code_path* -o *after_compiling_path* -std=c++17 ` . 请使用真正的路径替换用**框起来的内容.

保证答案唯一。请不要输出多的空格或换行符号。如果你需要换行，请使用`\n` ，请使用`' '` 表示空格，而不是其他.

## 样例输入

```
#include <cstdio>
int main(){int a, b; scanf("%d%d", &a, &b); printf("%d\n", a+b); printf("%d\n", a-b); printf("%d\n", a%b);return 0;}
end
3
1 1
1 4
1 3
```

## 样例输出

```
#include <cstdio>
int main(){
	int a, b;
	scanf("%d%d", &a, &b);
	printf("%d\n", a + b);
	printf("%d\n", a - b);
	printf("%d\n", a%b);
	return 0;
}
int a, b;
printf("%d\n", a - b);
printf("%d\n", a + b);
```

## 测试点

对于 $5\%$ 的测试点，只需要满足条件A，不存在任何询问.

对于另外 $10\%$ 的测试点，需要满足A，B，不存在任何询问.

对于另外 $25\%$ 的测试点，需要满足A，B，C，不存在任何询问.

对于另外 $25\%$ 的测试点，需要满足A，B，C，$m\le10$.

对于剩下的测试点，$m\le1000$.



