# 题目 For mad der (Formatter)

## 题目背景

故事发生在公元907年.

为了无时无刻让人们听到der的语文课，使得不要让唐完了，「问号」用张浩阳博士开发的C--语言创造了一个虚拟的der，有一天der突然被bug（真）袭击了，开始疯狂输出，「问号」立刻向一位叫「程宇翔」的巨佬求救，「程宇翔」在电脑上写好代码后就消失了，但是当时存储寸土寸金，他的代码没有经过格式化，「问号」并不能看懂.

问号希望你可以在 $1000ms$ 内将他的代码格式化，并且输出一些关键性的代码，否则安禄山就要进长安了.（喜）

## 题目内容

输入一段C++代码，然后格式化代码，代码长度为 $n\;(n\le10^6)$

要求字符串中的内容不被格式化，注释里的代码需要被格式化，

在所有下面给出的符号的前后添加空格，符号包括`+-*/=><|^~`, （%和&被迫移除）

同时包括`&&`和`||`和`<<`和`>>`和`?`和`:`，如果空格已经添加过则不添加，

如果本行的第一个字符（忽略空格）为`#`并且后面有单词`include`或者`define`则对于`<`和`>`不执行添加空格的操作，

保证`#`号后面不会出现这两个单词之外的单词

每个分号后面添加换行，如果已经换行则不添加，

对于没有添加缩进的地方，自动添加大小为 $4$ 个空格的缩进，

保证最后一行为空行。

之后给出 $m\;(m\le 500)$ 次询问，每次给出 $i,j$ ，回答第 $i$ 个代码块的第 $j$ 个语句是什么.

保证一定存在答案.

为了更直观地理解询问这个过程，我将用一段代码做演示：

```cpp
#include <cstdio> // 代码块 1

// 实际给出的测试例中不可能出现上面的空行
typedef long long lld; // 代码块 2
const int LN = 17, N = (1 << LN) + 11; // 代码块 3
int n, m; // 代码块 4
lld sum[N], tag[N]; // 代码块 5
// pushup // 不算
void up(int v){ // 代码块 6
	sum[v] = sum[v << 1] + sum[v << 1 | 1]; // 代码块 6 语句 1
} // 忽略
/*modify*/ // 不算
void modify(int q, lld& val){ // 代码块 7
	sum[q] += val << (__builtin_clz(q) - (32 - LN)); // 代码块 7 语句 1
	tag[q] += val; // 代码块 7 语句 2
}
void solve(){ // 代码块 8
	while(m--){ // 代码块 9
		int op, l, r, i; // 代码块 9 语句 1
		lld val; // 代码块 9 语句 2
		scanf("%d%d%d", &op, &l, &r); // 代码块 9 语句 3
		r++; // 代码块 9 语句 4
		if(op == 1){ // 代码块 10
			scanf("%lld", &val); // 代码块 10 语句 1
			upd = modify; // 代码块 10 语句 2
		}else{ // 代码块 11
			val = 0; // 代码块 11 语句 1
			upd = query; // 代码块 11 语句 2
    }
}

```

## 样例输入

```
#include <cstdio>
int main(){int a, b; scanf("%d%d", &a, &b); printf("%d\n", a+b); printf("%d\n", a-b);}

3
1 1
1 4
1 3
```

## 样例输出

```
#include <cstdio>
int main(){
	int a, b;
	scanf("%d%d", &a, &b);
	printf("%d\n", a + b);
	printf("%d\n", a - b);
}
int a, b;
printf("%d\n", a - b);
printf("%d\n", a + b);
```

